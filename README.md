# Simple_P2P_chatsystem (C & Go Comparison)
ネットワークプログラミングの基礎であるソケット通信を題材に、同ネットワーク内の2者間でのリアルタイム通信を、C言語とGo言語で実装した。

## 1.C言語による2つのアプローチの比較
C言語版では、2種類の実装を行った。
| 比較項目 | Socket 通信 UDP (`udp_chat.c`) | Raw Socket (`raw_chat.c`) |
| :--- | :--- | :--- |
| **抽象度** | **高い**（OSがヘッダーを自動処理） | **低い**（ヘッダーを自力で構築） |
| **主な処理** | `sendto` / `recvfrom` の単純な呼出 | IP/UDPヘッダー構築、チェックサム計算 |
| **実行権限** | 一般ユーザー権限 | **管理者権限 (sudo)** が必須 |
| **実装の難易度** | 中（ソケットプログラミングの基礎） | 高（パケット構造の理解が必要） |
| **I/O 多重化** | `epoll` による多重化 | `epoll` による多重化 |

## 2.Go言語での実現
C言語の実装ではヘッダーや多重化の処理が煩雑であったが、Go言語では同機能の実装がより簡単にできた。
### C言語:  epoll_waitを含むイベントループを自分で管理し、発生したイベントを条件分岐で処理できる。構造体の初期化やバイトオーダーの変換処理が必要である。
### Go言語: 受信処理をGoroutine (go func()) として切り出し、Goのランタイムが内部的にepoll等を管理するため、コード上では「入力待ち」と「受信待ち」を独立した直列処理として扱える。

## 3.実行コマンド
### 3.1 udp_chat.c
① cd chatsystem_C 
② make start
③ make login-node1
④ gcc udp_chat.c -o udp_chat
⑤ ./udp_chat 10.100.0.20
⑥ (別画面で①の後) make login-node2 
⑦　./udp_chat 10.100.0.10
⑧ チャット開始

### 3.2 raw_chat.c
① cd chatsystem_C
② make start
③ make login-node1
④ gcc raw_chat.c -o raw_chat
⑤ sudo ./raw_chat 10.100.0.10 10.100.0.20
⑥ (別画面で①の後) make login-node2 
⑦　./raw_chat 10.100.0.20 10.100.0.10
⑧ チャット開始

### 3.3 go_chat.go
① cd chatsystem_Go
② make start
③ make login-node1
④ go run go_chat.go 10.100.0.20
⑤ (別画面で①の後) make login-node2 
⑥ go run go_chat.go 10.100.0.10
⑦ チャット開始

## 4.C言語実装に対する、Go言語実装のメリット・デメリット
### メリット
#### 高い生産性と可読性
C言語ではepollなどの複雑なコードにより100行から150行のコード量が必要であったが、Go言語では同じ機能を60行ほどで実装できた。
#### メモリ安全性
固定長バッファの管理やオーバーフローのリスクが、Goのスライスとガベージコレクションによって解消される。
#### 標準ライブラリの強力さ
外部ライブラリを使わずに、安全かつ効率的なネットワーク処理が完結する。
### デメリット
#### 低レイヤーへのアクセスの制限
raw_chat.cで行ったような、IPヘッダーを1ビット単位で操作する処理は、標準ライブラリの範囲外となり、対応できない。
#### ランタイムの隠蔽
epollやシステムコールがどのように呼ばれているかが見えにくくなるため、ブラックボックス化してしまう。
#### バイナリサイズ
実行環境に依存しない静的バイナリを作成できるが、ランタイムを含むため、C言語に比べるとサイズが大きくなる。実際、チャット開始までの時間は体感でもC言語より長くなった。

## 5.実装の様子
どの手法でも以下のようなチャットが可能になった。
<p align="left">
  <img src="images/10.100.0.10.png" width="200">
</p>
<p align="right">
  <img src="images/10.100.0.20.png" width="200">
</p>

## 6.結論
ソケットプログラミングの基礎を学び、実際にC言語で実装することで学びを深めることができた。更に、Go言語で効率的かつ安全に抽象化してシステムを構築できると分かり、ネットワークプログラミングの深層からモダンな開発手法までの連続性を体験することができた。次は、Go言語での多人数対戦ゲームを構築したい。
